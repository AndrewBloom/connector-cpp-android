diff --git a/cdk/cmake/DepFindProtobuf.cmake b/cdk/cmake/DepFindProtobuf.cmake
index 1fc785e3..55af684e 100644
--- a/cdk/cmake/DepFindProtobuf.cmake
+++ b/cdk/cmake/DepFindProtobuf.cmake
@@ -77,6 +77,12 @@ function(mysqlx_protobuf_generate_cpp SRCS HDRS)
   SET(srcs)
   SET(hdrs)
 
+  if (NOT CMAKE_CROSSCOMPILING)
+    set(PROTOC_CMD ext::protoc)
+  else()
+    set (PROTOC_CMD ${WITH_PROTOC})
+  endif()
+
   FOREACH(FIL ${ARGN})
     GET_FILENAME_COMPONENT(ABS_FIL ${FIL} ABSOLUTE)
     GET_FILENAME_COMPONENT(FIL_WE ${FIL} NAME_WE)
@@ -90,7 +96,7 @@ function(mysqlx_protobuf_generate_cpp SRCS HDRS)
       "${CMAKE_CURRENT_BINARY_DIR}/protobuf/${FIL_WE}.pb.h"
       COMMAND ${CMAKE_COMMAND}
       -E make_directory "${CMAKE_CURRENT_BINARY_DIR}/protobuf"
-      COMMAND ext::protoc
+      COMMAND ${PROTOC_CMD}
       ARGS --cpp_out "${CMAKE_CURRENT_BINARY_DIR}/protobuf"
       -I ${ABS_PATH} ${ABS_FIL}
 
diff --git a/cdk/cmake/dependency.cmake b/cdk/cmake/dependency.cmake
index e3fec4ee..35412ab9 100644
--- a/cdk/cmake/dependency.cmake
+++ b/cdk/cmake/dependency.cmake
@@ -62,6 +62,18 @@ set(EXT_FWD
   MSVC
 )
 
+# ANDROID SPECIFIC VARIABLES FOR CROSS COMPILATION
+get_cmake_property(cache_vars CACHE_VARIABLES)
+
+foreach(var ${cache_vars})
+    if(var MATCHES "ANDROID|TOOLCHAIN")
+        get_property(type CACHE ${var} PROPERTY TYPE)
+        if(NOT type STREQUAL "INTERNAL")
+            list(APPEND EXT_FWD ${var})
+        endif()
+    endif()
+endforeach()
+
 set(EXT_DIR ${CMAKE_CURRENT_LIST_DIR}/ext CACHE INTERNAL "external project utils location")
 
 
diff --git a/cdk/foundation/socket_detail.cc b/cdk/foundation/socket_detail.cc
index ffea5d61..19e15c75 100644
--- a/cdk/foundation/socket_detail.cc
+++ b/cdk/foundation/socket_detail.cc
@@ -56,6 +56,9 @@ PUSH_SYS_WARNINGS_CDK
 #include <windns.h>
 #pragma comment(lib,"Dnsapi")
 #endif
+#ifdef __ANDROID__
+#include <android/multinetwork.h>
+#endif
 POP_SYS_WARNINGS_CDK
 
 using namespace std::chrono;
@@ -1090,6 +1093,60 @@ std::forward_list<Srv_host_detail> srv_list(const std::string &hostname)
   }
   return srv;
 }
+#elif defined(__ANDROID__)
+
+std::forward_list<Srv_host_detail> srv_list(const std::string &hostname)
+{
+  net_handle_t network = NETWORK_UNSPECIFIED;  // Use default network
+  using Srv_list = std::forward_list<Srv_host_detail>;
+  Srv_list srv;
+  Srv_list::const_iterator srv_it = srv.before_begin();
+
+  // Perform DNS SRV query using Android's native networking API
+  int query_fd = android_res_nquery(network, hostname.c_str(), ns_c_in, ns_t_srv, 0);
+  if (query_fd > 0) {
+    // Allocate buffer for DNS response
+    unsigned char query_buffer[NS_PACKETSZ];
+    int rcode;
+
+    // Retrieve query result from file descriptor
+    int res = android_res_nresult(query_fd, &rcode, query_buffer, sizeof(query_buffer));
+    if (res > 0) {
+      ns_msg msg;
+      char name_buffer[NS_MAXDNAME];
+      Srv_host_detail host_data;
+      ns_initparse(query_buffer, res, &msg);
+
+      auto process = [&msg, &name_buffer, &host_data, &srv, &srv_it](const ns_rr &rr) -> void
+      {
+        const unsigned char* srv_data = ns_rr_rdata(rr);
+
+        //Each NS_GET16 call moves srv_data to next value
+        NS_GET16(host_data.prio, srv_data);
+        NS_GET16(host_data.weight, srv_data);
+        NS_GET16(host_data.port, srv_data);
+
+        dn_expand(ns_msg_base(msg), ns_msg_end(msg),
+                  srv_data, name_buffer, sizeof(name_buffer));
+
+        host_data.name = name_buffer;
+
+        srv_it = srv.emplace_after(
+                   srv_it,
+                   std::move(host_data));
+        };
+
+        for(int x= 0; x < ns_msg_count(msg, ns_s_an); x++)
+        {
+              ns_rr rr;
+              ns_parserr(&msg, ns_s_an, x, &rr);
+              process(rr);
+        }
+    }
+  }
+  return srv;
+}
+
 #else
 
 std::forward_list<Srv_host_detail> srv_list(const std::string &hostname)
